# Chapter 4. Basic Expressions and Function Writing
Sunday, October 12, 2014  

**NOTICE**: The main references of this material are: 
* i) [learnR](http://renkun.me/learnR/): Chapter 3. Basic Expressions; 
* ii) [R Language Definition](http://cran.r-project.org/doc/manuals/R-lang.pdf): Chapter 3. Evaluation of Expressions, Chapter 4. Functions. 

## Introduction

Expressions and functions play essential roles in R programming, especially when the analytic tasks are too complicated to use several existed functions to complete. In these situations, loops and functions are often used to control the execute procedure of the program. In this chapter we will explore some basic but useful skills in R programming, and we will also have some examples related to finance study to show how to organize your idea, and transform mathematical models to R programs.

### Contents

* Basic Expressions
  * Assignment
  * Operators
  * Conditions
  * Loop
  
* Function Writing
  * Elements of a Function
  * Syntax
  * Arguments
  * Return
  * Statements
  * Apply Family
  * Further Topics

* Applications
  * Fibonacci Sequence
  * Discrete Markov Chain
  * Basic Option Pricing Models

## Basic Expressions

### Assignment

Assignment might be the most fundamental expressions used in any programming languages. An object in R can be imagined as a box, and  we are able to put anything we want into the box by assignning contents to that object. 

For example, if we want to create a sequence starts from 1 and ends at 5, and assign it to `x`, we have several choices to perform this assignment:


```r
1:5       # it will be displayed in console but stored in nowhere 
```

```
## [1] 1 2 3 4 5
```

```r
x <- 1:5  # first way to assign it
1:5 -> x  # second way
x = 1:5   # third way
```
We may be familiar with the third way but the most often used method is the first one (using `<-`). 

Assignment chain is also allowed in R:


```r
x <- y <- z <- 0
c(x, y, z)
```

```
## [1] 0 0 0
```
Notice the expression `0` is evaluated only once here. To verify how it works, we can change `0` to a random number generator.


```r
x <- y <- z <- rnorm(1)
c(x, y, z)
```

```
## [1] -0.2638 -0.2638 -0.2638
```

### Operators

`+,-,*,/` are all operators in R language. There are a number of operators in R. You may refer to [R Language Definition](http://cran.r-project.org/doc/manuals/R-lang.pdf) Page 10 to find all of them. Here we divide these operators into three catgories: mathematical operators and logical operators and others, and we will use some examples to show how to use them.

#### Mathematical Operators

Mathematical operators are easy to understand:


```r
x <- 2
y <- 5
x + y
```

```
## [1] 7
```

```r
x - y 
```

```
## [1] -3
```

```r
x * y
```

```
## [1] 10
```

```r
x / y
```

```
## [1] 0.4
```

```r
x ^ y
```

```
## [1] 32
```

```r
x : y
```

```
## [1] 2 3 4 5
```

```r
y %% x  # modulus 5%%2 = 1
```

```
## [1] 1
```

```r
y %/% x # interger divide 5%/%2 = 2
```

```
## [1] 2
```

Notice, `*` is different from what we have learned in math class when it is applied to matrix. To perform the so-called "matrix production", we should use `%*%`.


```r
x <- matrix(1:9, nrow=3)
y <- matrix(1:9, nrow=3, byrow=TRUE)
x * y
```

```
##      [,1] [,2] [,3]
## [1,]    1    8   21
## [2,]    8   25   48
## [3,]   21   48   81
```

```r
x %*% y
```

```
##      [,1] [,2] [,3]
## [1,]   66   78   90
## [2,]   78   93  108
## [3,]   90  108  126
```

#### Logical Operators

Logical operators, or Boolean operators are used to calculate logical relationships. The first thing we should know is that logical value, which includes `TRUE` and `FALSE`, is also a kind of variables. 


```r
x <- TRUE
class(x)
```

```
## [1] "logical"
```

The simplest situation happens when we want to know whether something is true or not. 


```r
x <- 1
y <- 2
z <- 2
x > y
```

```
## [1] FALSE
```

```r
z >= y
```

```
## [1] TRUE
```

```r
z == y
```

```
## [1] TRUE
```

```r
x == y
```

```
## [1] FALSE
```

```r
z != y
```

```
## [1] FALSE
```

These operators are used to compare the values of two variables. R also provides a useful operator `%in%` to find if a certain element exist in another object.

```r
y <- c(1, 3, 5, 6)
3 %in% y
4 %in% y
```

Using these operators we can find if a statement is true or not. However, sometimes we also need to calculate the relationship between two statemetn. The basic calculations of two logical values are `and`, `or` and `not`, which combines two simple statement to one complex/compound statement, or reverse the logical value. 


```r
x <- TRUE
y <- FALSE
x | y
```

```
## [1] TRUE
```

```r
x & y
```

```
## [1] FALSE
```

```r
!(x) & y
```

```
## [1] FALSE
```

```r
!(x | y)
```

```
## [1] FALSE
```

Notice, two operators are provided to calculation `and`, `&` and `&&`, and two operators for `or`, `|` and `||`. 


```r
x <- c(TRUE, FALSE, TRUE)
y <- c(FALSE, TRUE, TRUE)
x & y
```

```
## [1] FALSE FALSE  TRUE
```

```r
x && y
```

```
## [1] FALSE
```

```r
x | y
```

```
## [1] TRUE TRUE TRUE
```

```r
x || y
```

```
## [1] TRUE
```

#### Other Operators

`$` and `~` are also listed as operators, but we will talk about it in further discussions.

### Conditions

How to tell my computer I want to execute certain codes only if some conditions are satisfied, and skip those lines when not satisfied? 

```r
if( condition ){
  statement
}
```

In this code, R will evaluate the condition and test if the conditional statement satisfied or not. The statement in bracket will be executed only if condition equals TRUE. 


```r
x <- 2
if( x == 1 ){
  z <- 1
}
z
```

```
## [1] 2
```

We may add `else` to test further conditions.

```r
if( condition.1 ){
  statement.1
} else if( condition.2 ) {
  statement.2
} else {
  statement.3
}
```

For example,


```r
signal <- 1

if( signal == 1 ){
  action <- "Open Long"
} else if( state == -1 ){
  action <- "Open Short"
} else if( state == 0 ){
  action <- "Close Position"
} else {
  action <- "Continue"
}

action
```

```
## [1] "Open Long"
```

For convenience, if-else sentence can be written in a single line.

```r
if( condition ) statement.1 else statement.2
```

Function `ifelse()` is very useful when the statement line is short:


```r
x <- 3
y <- ifelse(x == 2, x^2, x*3)
y
```

```
## [1] 9
```

Besides the logical operator we have mentioned, function `any()` and `all()` are also often used when there are a lot of conditions to test.


```r
x <- c(1, 3, 5, 2)
all( x > 2 )
```

```
## [1] FALSE
```

```r
any( x == 3)
```

```
## [1] TRUE
```

`switch()` is also used to deals with conditions, but in a different way.


```r
switch(1,"x","y") # the n-th argument will be returned.
```

```
## [1] "x"
```

```r
switch(2,"x","y")
```

```
## [1] "y"
```

If the number is larger than the number of followed arguments, a `NULL` will be returned.


```r
switch(3,"x","y")
```

`switch()` performs differently when the input is a character.


```r
switch("a",a=1,b=2)
```

```
## [1] 1
```

```r
switch("b",a=1,b=2)
```

```
## [1] 2
```

```r
switch("c",a=1,b=2)
```

### Loop 

Computers does not know how to prove a new mathematical theorem, but knows how to make simple calculations thousands times withins seconds. 
By looping, we divide a complicated task into repeated calculations. For example, using `for-looping`:


```r
y <- 0
for( i in 1:100 ){
  y <- y+i
}

y
```

```
## [1] 5050
```

From this example you may guess how `for-loop` works in R. General syntax for `for-loop` is

```r
for( iterator in vector ){
  statement to be evaluated each time
}
```

Notice 1, iterator is changing during the looping, and will still exist after loop (a kind of side effect).

Notice 2, we usually use vectors for looping, but `list`, `data.frame` can also be used for looping.


```r
df <- data.frame(a=rnorm(100, mean=1), b=rnorm(100, mean=0), c=rnorm(100, mean=3) )
for( var in df ){
  message( mean(var) )
}
```

```
## 1.05629170883584
## -0.193954797681854
## 2.86135258665476
```

```r
lists <- list(a=rnorm(100, mean=1), b=rnorm(50, mean=0), c=rnorm(800, mean=3))
for( x in lists ){
  message( mean(x) )
}
```

```
## 0.94618365188732
## 0.0882155143056008
## 2.95745802912501
```

`next` and `break` gives us further controls over the program. `next` skips following lines in this time, and `break` stops the whole iteration.


```r
s <- 0
for( i in 1:10 ){
  if( i == 3 ) next
  if( i == 6 ) break
  s <- s+i
}

s
```

```
## [1] 12
```

Notice the positions of `next` and `break` lines will change the result.


```r
s <- 0
for( i in 1:10 ){
  if( i == 6 ) break
  s <- s+i
  if( i == 3 ) next
}

s
```

```
## [1] 15
```

`repeat` and `while` are also used for looping. 

```r
repeat statement
```

Remember you must give termination condition and use `break` to stop the loop, and also the termination condition must be satisfied some time, or you will never get out the loop! Actually it not easy to know whether the termination condition will be satisfied in the "future", and for this reason `repeat-loop` is seldom used in practice.

The last way to loop is `while-loop`.
```r
while( condition ){
  statement
}
```

`while-loop` is very similar to `repeat-loop`, but gives the termination condition more explicitly. In `while-loop`, the statement will be evaluated only if `condition` equals `TRUE`.

For the same reason, `while-loop` is also seldom used, but they are useful especially when we do not know when to stop the loop.


```r
s <- 0
i <- 1  # remember to creat iterator by yourself.
while( s < 1000 ){
  s <- s + i
  i <- i + 1  # remember to renew your interator.
}

s
```

```
## [1] 1035
```

However, we are still able to use `for-loop` to do the same thing.


```r
s <- 0
for( i in 1:1e8 ){
  if( s+i >= 100 ) break
  s <- s + i
}

s
```

```
## [1] 91
```

## Function Writing

### Elements of A Function

Before start learning how to write a function in R, we firstly consider what a function really is. 

In mathematics, a function is a kind of rule. When we put a number `x` into the function, it will be mapped to another number `y`. It seems like a black-box if we ignore how `x` is processed in it, but just focus on its input and output. 

In any kind of programming language, function works in the same way. Consider function `factorial()`:


```r
factorial(5)
```

```
## [1] 120
```

This calculates $n\times(n-1)\times(n-2)\dots\times1$. Here the input number is `5`, the output number is `120`. And how the input number `5` is processed is given by the equation.

So we can divide a function into three parts:
* 1. The input (`5`)
* 2. The output (`120`)
* 3. How the input is procced into the output. ( $n\times(n-1)\times(n-2)\dots\times1$)

In R (and in any other programming language), we define them as:
* 1. Arguments
* 2. Return
* 3. Statements

If we want to write a function, we must be clear about all these three things. Ask yourself what are given, what you want, and how to connect these two things.

### Syntax

Different language has different syntax for writing functions. In R, we create a function in this way:

```r
function.name <- function( argument.1, argument.2 ){
  statements...
  return(result)
}
```

Here we just give a simple example:


```r
myfun <- function(x, a, b){
  y <- a + b*x
  return(y)
}
```

Notice, a function is also a kind of object in R:


```r
class(myfun)
```

```
## [1] "function"
```

When the function is created, we can use it just as any existed functions in R.


```r
myfun(x=3, intercept=1, slope=2)
```

```
## Error: 参数没有用(intercept = 1, slope = 2)
```

### Arguments

#### Argument Matching

All of the following are allowed in R:


```r
myfun(x=3, a=1, b=2)
```

```
## [1] 7
```

```r
myfun(a=1, b=2, x=3)
```

```
## [1] 7
```

```r
myfun(3, 1, 2)
```

```
## [1] 7
```

```r
myfun(x=3, 1, 2)
```

```
## [1] 7
```

The first two examples are called "exact matching", since they give the exact names of all arguments.

The second way is called "positional matching". 

Also, we can use "partial matching" sometimes, though not recommended. (See [R Language Definition](http://cran.r-project.org/doc/manuals/R-lang.pdf), Page 23, 4.3.2)

#### Default Value

We can set default values to the function:


```r
myfun <- function(x, a=1, b=2){
  y <- a + b*x
  return(y)
}
```

We have different choices to call the function `myfun()`:


```r
myfun(1)
```

```
## [1] 3
```

```r
myfun(x=1, a=2, b=3)
```

```
## [1] 5
```

```r
myfun(1, a=3)
```

```
## [1] 5
```

( This actually used a mechanism inside R called "lazy evaluation". To know more, read: [Lazy Evaluation](http://renkun.me/learnR/inside-r/lazy-evaluation.html) )

### Return

#### Using `return()`

In the examples above, we used `return()` to tell R which object to be returned when we call the function. However, `return()` is not a must in a function. R will return the last shown object.


```r
myfun <- function(x, a, b){
  y <- a + b*x
}
```


```r
myfun(3, 1, 2)

z <- myfun(3, 1, 2)
z
```

```
## [1] 7
```

Notice, at this time the result will not be shown, but it can still be assigned to another object.

We can also simplify the function in this way:


```r
myfun <- function(x, a, b) y <- a + b*x

z <- myfun(3, 1, 2)
z
```

```
## [1] 7
```

However, we usually recommend to explicitly write `return()` to make the codes more readable.

#### What if we do not care about the return?

In some situations, we do not care about what its return is. We use these functions to plot, to write data and so on. These actions are also allowed in R, and they do not need a specific return. 

For example, we want a function to plot `n` random numbers:


```r
plot.rnorm <- function(n){
  rand <- rnorm(n)
  plot(rand)
}
```

When we call this function, it will plot directly.


```r
plot.rnorm(100)
```

![plot of chunk unnamed-chunk-34](figure/unnamed-chunk-34.png) 

Still, we want to know what if we assign it to an object.


```r
test <- plot.rnorm(100)
```

![plot of chunk unnamed-chunk-35](figure/unnamed-chunk-35.png) 

```r
test
```

```
## NULL
```

Think about why. The reason is `plot(rand)` is the last line in the function, and `plot()` function returns the `NULL`! 

Though we usually do not do it this way, we must be clear about what happens in a function. In these situations, one recommended way is to let the function `return(TRUE)`. This is a good habit especially in complex tasks. 

### Statements

There is nothing special to tell about statements, though these statements are the main body of a function. The reason is, you are writing in the same as you are writing an R script.

### Apply Family

??????

### Further Topics

Here we just list some further topics of R programming. These topics are about the underlying mechanisms. Though your codes still works if you have no idea about these stuffs, these things will become important when you get more and more familiar with R.

* Recycling Rules (See [R Language Definition](http://cran.r-project.org/doc/manuals/R-lang.pdf), Page 15, 3.3.1)
* Copy on Write
* Lazy Evaluation ([learnR](http://renkun.me/learnR/inside-r/lazy-evaluation.html), 8.1)
* Scoping (See [R Language Definition](http://cran.r-project.org/doc/manuals/R-lang.pdf), Page 20, 3.5)
* Debugging (See [R Language Definition](http://cran.r-project.org/doc/manuals/R-lang.pdf), Page 40, 9)
* dot-dot-dot

## Application 

Equipped with the knowledge of operators, conditions and looping, we now come into a new topic: build your own program.

This is a very exiting part because it shows how you can tell your computer to work as you like and finish your tasks. Even the most complicated algorithm is generated from these structures, and you can show how creative you are using these basic tools.

### Fibonacci Sequence

The generation of Fibonacci sequence is often used as study examples and also used to test the efficiency of a programming language.


```r
n <- 50
fib <- c(1, 1)

for( i in 3:50 ){
  fib[i] <- fib[i-1] + fib[i-2]
}

fib
```

```
##  [1] 1.000e+00 1.000e+00 2.000e+00 3.000e+00 5.000e+00 8.000e+00 1.300e+01
##  [8] 2.100e+01 3.400e+01 5.500e+01 8.900e+01 1.440e+02 2.330e+02 3.770e+02
## [15] 6.100e+02 9.870e+02 1.597e+03 2.584e+03 4.181e+03 6.765e+03 1.095e+04
## [22] 1.771e+04 2.866e+04 4.637e+04 7.502e+04 1.214e+05 1.964e+05 3.178e+05
## [29] 5.142e+05 8.320e+05 1.346e+06 2.178e+06 3.525e+06 5.703e+06 9.227e+06
## [36] 1.493e+07 2.416e+07 3.909e+07 6.325e+07 1.023e+08 1.656e+08 2.679e+08
## [43] 4.335e+08 7.014e+08 1.135e+09 1.836e+09 2.971e+09 4.808e+09 7.779e+09
## [50] 1.259e+10
```

### Discrete Markov Chain Simulation

Consider a discrete state transition stochastic procedure:


```r
trans.mat <- matrix(0, 3, 3)
trans.mat[1, ] <- c(0.1, 0.3, 0.6)
trans.mat[2, ] <- c(0.3, 0.4, 0.3)
trans.mat[3, ] <- c(0.4, 0.6, 0)
trans.mat
```

```
##      [,1] [,2] [,3]
## [1,]  0.1  0.3  0.6
## [2,]  0.3  0.4  0.3
## [3,]  0.4  0.6  0.0
```

How to simulate this procedure?


```r
cum.trans.mat <- t( apply(trans.mat, MARGIN=1, cumsum) )

state <- 2
sim <- c(state)

for( i in 2:1000 ){
  
  if( state == 1 ){
    rand <- runif(1)
    state <- ifelse(rand <= cum.trans.mat[1, 1], 1, 
                    ifelse(rand <= cum.trans.mat[1, 2], 2, 3) )
    sim[i] <- state
  } else if ( state == 2 ){
    rand <- runif(1)
    state <- ifelse(rand <= cum.trans.mat[2, 1], 1, 
                    ifelse(rand <= cum.trans.mat[2, 2], 2, 3) )
    sim[i] <- state
  } else if ( state == 3 ){
    rand <- runif(1)
    state <- ifelse(rand <= cum.trans.mat[3, 1], 1, 
                    ifelse(rand <= cum.trans.mat[3, 2], 2, 3) )
    sim[i] <- state
  }
  
}
```

We can also simplify the codes. Think about why it works, and why `break` is needed in this code.


```r
for( i in 2:1000 ){  
  for( j in 1:3 ){
    if( state == j ){
      rand <- runif(1)
      state <- ifelse(rand <= cum.trans.mat[j, 1], 1, 
                      ifelse(rand <= cum.trans.mat[j, 2], 2, 3) )
      sim[i] <- state
      break
    }
  }
}
```

Test if the simulation is consistency with the given matrix.


```r
test <- table( sim[1:999], sim[2:1000] )
test
```

```
##    
##       1   2   3
##   1  20  88 146
##   2 119 183 149
##   3 115 179   0
```

```r
test/rowSums(test)
```

```
##    
##           1       2       3
##   1 0.07874 0.34646 0.57480
##   2 0.26386 0.40576 0.33038
##   3 0.39116 0.60884 0.00000
```

```r
trans.mat
```

```
##      [,1] [,2] [,3]
## [1,]  0.1  0.3  0.6
## [2,]  0.3  0.4  0.3
## [3,]  0.4  0.6  0.0
```

### Basic Option Pricing Models

#### Black-Scholes Option Pricing Model

In BS model, the price of a option is given by:

$C=S\times N(-d_1) - K\times e^{T-t_0}\times N(d_2)$
$P=K\times e^{T-t_0}\times N(-d_2)-S\times N(-d_1)$

Where $T$ is the a future time point, $t_0$ is right now. $S$  is the price of underlying asset, and $K$ is executive price of the option. 


```r
S <- 50
K <- 52
r <- 0.01
sigma <- 0.5
Time <- 0.25
t0 <- 0

d1 <- ( log(S/K) + (r+sigma^2/2)*(Time-t0) ) / ( sigma*sqrt(Time-t0) )
d2 <- ( log(S/K) + (r-sigma^2/2)*(Time-t0) ) / ( sigma*sqrt(Time-t0) )

C <- S*pnorm(d1) - K*exp(-r*(Time-t0))*pnorm(d2)
P <- K*exp(-r*(Time-t0))*pnorm(-d2) - S*pnorm(-d1)  

c(C, P)
```

```
## [1] 4.186 6.056
```

How to make the codes reusable? Notice both $C$ and $P$ are functions of parameters $S$, $T$, $t_0$, $\sigma$ and $r$. 

$C=F_c(S, T, t_0, \sigma, r)$
$P=F_p(S, T, t_0, \sigma, r)$

Using them as arguments, we can write two functions to calculate the theoretical price.


```r
bs.eurocall <- function(S, K, r, sigma, Time, t0){
  d1 <- ( log(S/K) + (r+sigma^2/2)*(Time-t0) ) / ( sigma*sqrt(Time-t0) )
  d2 <- ( log(S/K) + (r-sigma^2/2)*(Time-t0) ) / ( sigma*sqrt(Time-t0) )
  
  eurocall <- S*pnorm(d1) - K*exp(-r*(Time-t0))*pnorm(d2)
  
  return(eurocall)  
}

bs.eurocall(50, 52, 0.01, 0.5, 0.25, 0)
```

```
## [1] 4.186
```


```r
bs.europut <- function(S, K, r, sigma, Time, t0){
  d1 <- ( log(S/K) + (r+sigma^2/2)*(Time-t0) ) / ( sigma*sqrt(Time-t0) )
  d2 <- ( log(S/K) + (r-sigma^2/2)*(Time-t0) ) / ( sigma*sqrt(Time-t0) )
  
  europut <- K*exp(-r*(Time-t0))*pnorm(-d2) - S*pnorm(-d1)  
  
  return(europut)  
}

bs.europut(50, 52, 0.01, 0.5, 0.25, 0)
```

```
## [1] 6.056
```

Notice these these two functions are quite similar with each other. We can add an argument called "type" to control what kind of option is going to be calculated.


```r
bs.optprc <- function(type, S, K, r, sigma, Time, t0){
  d1 <- ( log(S/K) + (r+sigma^2/2)*(Time-t0) ) / ( sigma*sqrt(Time-t0) )
  d2 <- ( log(S/K) + (r-sigma^2/2)*(Time-t0) ) / ( sigma*sqrt(Time-t0) )
  
  if(type == "euro.call") optprc <- S*pnorm(d1) - K*exp(-r*(Time-t0))*pnorm(d2)
  if(type == "euro.put")  optprc <- K*exp(-r*(Time-t0))*pnorm(-d2) - S*pnorm(-d1)  
  
  return(optprc)  
}

bs.optprc(type="euro.call", 50, 52, 0.01, 0.5, 0.25, 0)
```

```
## [1] 4.186
```

#### Binomial Tree Model

Binomial tree model is another famous option pricing model. This model assumes the price of the uderlying asset will go up or go down in a certain rate during every single period of time. We can calculate the change rate of price, and the probability to go up. 

The final price of the option is introduced firstly, and then we can trace back to the original price and get the theoretical price right now.


```r
binom.optprc <- function(type, S, K, r, sigma, Time, N){

  dt <- Time/N
  
  u <- exp(sigma*sqrt(dt))
  d <- 1/u
  p <- (exp(r*dt)-d)/(u-d)
  
  tree <- matrix(0, nrow=N+1, ncol=N+1)
  
  for( y in 0:N ){
    if( type=='call' )  tree[y+1, N+1] <- max(0, S*(u^y)*(d^(N-y))-K )     
    if( type=='put'  )  tree[y+1, N+1] <- max(0, K - S*(u^y)*(d^(N-y)) )   
  }
    
  for( x in seq(from=N, to=1, by=-1) ){
    for( y in seq(from=1, to=x, by=1) ){
      if( type=='call' ) tree[y, x] <- exp(-r*dt)*(p*tree[y+1, x+1] + (1-p)*tree[y, x+1]) 
      if( type=='put'  ) tree[y, x] <- exp(-r*dt)*(p*tree[y+1, x+1] + (1-p)*tree[y, x+1])   
    }
  }
  
  optprc <- tree[1, 1]
  
  return(optprc)
}

binom.optprc(type='call', S=50, K=52, r=0.01, sigma=0.5, Time=0.25, N=30)
```

```
## [1] 4.225
```

```r
binom.optprc(type='put', S=50, K=52, r=0.01, sigma=0.5, Time=0.25, N=30)
```

```
## [1] 6.095
```

